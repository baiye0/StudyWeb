# 面试题

## 1.HTML

### 如何理解HTML语义化？

```
1.让人更容易读懂（增加代码可读性）
2.让搜索引擎更容易读懂（SEO(搜索引擎优化）
```

![1590137915951](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590137915951.png)



### 默认情况下，哪些是块级元素哪些是内联元素

```
块级元素:display:block/table;有div h1 h2... table ul ol p等
内联元素:inline/inline-block;有span img input button等
```



## 2.CSS

### 布局

* 盒子模型的宽度如何计算

  ```javascript
  //如下代码中,请问div1的offsetWidth是多大
  //offsetWidth:指的是盒模型的边框 + 内边距 + 内容的宽度,无外边距
  //100+10*2+1*2=122px
  <style>
      #div1 {
  		width:100px; 
  		padding:10px;
  		border:1px solid #ccc;
          margin:10px;
  }
  </style>
  <div id="div1"></div>
  
  //如果让offsetWidth等于100px,该怎么做?
  //1.width改为78px(不推荐)  2.box-sizing:border-box 让width的宽度为整个盒子的宽度
  ```

  补充:

  - 盒模型里面的内容（content），也就是实实在在要展现的内容，比如P标签里面的文字

  - 盒模型的内边距（padding）,是内容与边框内部之间的距离

  - 盒模型的边框（border）,边框也可以设置宽度

  - 盒模型的外边距（margin）,盒模型的边框外部与其他盒模型边框外部之间的距离

     ![CSS box-model](https://www.runoob.com/images/box-model.gif) 

* margin纵向重叠的问题

  ![1590139662580](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590139662580.png)

  ```javascript
  //AAA和BBB之间的距离是多少?
  //15px margin-bottom和下一个的margin-top取最大的.
  //相邻元素的margin-top和margin-bottom会发生重叠 空白内容的<p></p>也会重叠，,一层一层的重叠
  <style>
      p {
          font-size:16px;
          line-height:1;
          margin-top:10px;
          margin-bottom:15px;
      }
  </style>
  <p>AAA</p>
  <p></p>
  <p></p>
  <p></p>
  <p>BBB</p>
  ```

  

* margin负值的问题

  ```javascript
  //对margin的top left right bottom .. 设置负值有何效果
  //margin-top和margin-left负值，元素向上、向左移动
  //margin-right负值，右侧元素左移，自身不受影响   会让左边元素认为他的宽度减少了。 当负值等于width时认识宽度为0
  ///margin-bottom负值，下方元素上移、自身不受影响
  
  
  ```

  

* BFC理解和应用(重点)

  ```
  什么是BFC?有何作用
  block format context ，块级格式化上下文
  一块独立渲染区域，内部元素的渲染不会影响边界以外的元素
  形成BFC的常见条件：
  float 不是 none
  position是absolute或fixed
  overflow不是visible  是hidden //overflow:hidden  溢出隐藏,会撑开盒子 清楚浮动
  display是flex inline-block等
  BFC的常见应用：
  清除浮动
  ```

  

* float布局的问题,以及clearfix

  1.如何实现圣杯布局和双飞翼布局 

   ![img](https://img.mukewang.com/climg/5dad7f4d000184c819201080.jpg) 

  ```
  目的：三栏布局，中间一栏最先加载和渲染
  两侧内容固定，中间内容随着宽度自适应
  ```

  圣杯布局难点：

  1. （1）本来三个小盒子都设置了浮动 ,它们应该在一行显示 ,也就是左右两个小盒子要在middle后面浮动 .但是middle设置宽度100%， 占据了父元素所有的空间，没有它们的位置 , 把它们两个挤下去了

     ![http://img.mukewang.com/climg/5d9dbf7b091de42505560277.jpg](https://img.mukewang.com/climg/5d9dbf7b091de42505560277.jpg)

     （2）margin-left设置负值，表示该元素距离其他元素的左侧距离，该元素会向左移动设置多少负值的距离。

     如果设置的值是百分比需要根据父级元素宽度计算的，所以设置-100%, left盒子会向左移动到父级宽度100%的位置，也就是父级的最左侧，因为父级元素设置了内边距，所以设置-100%会移动到如下图绿色盒子所在的位置，也就会覆盖再center盒子上了

     ![http://img.mukewang.com/climg/5d9dbf9a09aaba7007940525.jpg](https://img.mukewang.com/climg/5d9dbf9a09aaba7007940525.jpg)

  2. 设置position:relative属性的元素， 是将依据LRTB(left,right,top,bottom)属性在其正常位置基础上偏移，right:200px 相当于 margin-left:-200px，所以是往左哦

  3. **右侧盒子设置负的margin-right值， 那么它占据页面的实际宽度就是 负的margin-right + width**， 当这个负值刚好等于自身宽度的时候， 我们可以理解为它实际占据页面的宽度为0，我们可以抽象的理解成它不占据位置， 所以可以在一排显示在最右侧了

   双飞翼布局：

  ```
  （使用margin为左右预留空间）
  不需要container包裹center，left，right（顺序不能有误）
  center下还要包一个div（center-wrap），称为内容器，center称为外容器
  外容器设置width：100%；height：自定义高度
  内容器设施margin： 0 left宽度 0 right宽度 ；(margin的值)
  left设置：margin-left：-100%；height：自定义高度；width：300px;（自定义left宽度）
  right设置：margin-left：- right的宽度；height：自定义高度；width：300px;（自定义 right宽度）
  最后设置center外容器，left，right******float：left
  ```

   2.手写clearfix

  ```
  手写clearfix
  .clearfix：after{
  content：""；
  display：block；
  clear：both；
  }
  
  写到子元素浮动的父元素上，防止父元素塌陷。
  ```

* flex画色子

  ```
  flex布局
  实现一个三点的色子
常用语法回顾：
  display：flex（弹性布局）
  属性：
  flex-direction用在父容器上，定义子元素的排列方向
  flex-direction：排列方式，默认横向（row，且起点在左边）
  flex-direction：row-reverse（横向排，起点在右边）
  flex-direction：column（竖着排，起点在上面column-reverse，起点在下面）
  
  justify-content（用在父元素上，定义子元素的对齐方式）
  属性：
  flex-start：开始对齐（左对齐）
  flex-end：结束对齐（右对齐）
  center：居中对齐
  space-between：两端对齐，子元素之间间隔相同
  space-around：子元素之间间隔相同，且与父元素间隔1/2距离
  
  align-items：（用在父元素上，定义子元素在交叉轴上的对齐方式，交叉轴是和主轴垂直的轴）
  flex-start：交叉轴起点对齐
  flex-end：交叉轴终点对齐
  center：交叉轴中心对齐
  baseline：了解
  stretch：了解
  
  align-self：（用在子元素上，定义元素在交叉轴上的对齐方式，交叉轴是和主轴垂直的轴）
  其属性和align-items一模一样，只是align-items用在父元素上，align-self用在子元素上
  ```
  
  

### 定位

* absolute和relative分别依据谁来定位

  ```
  relative：依据其在普通流中的定位，也就是自身进行定位
  absolute：依据最近一层上级定位元素进行定位（如爷元素有relative定位，那么absolute相对于爷元素进行定位，如果是父元素，这依据父元素进行定位）（定位元素包括，absolute，relative，fixed，如果都没有那就是相对body定位）
  
  ```

* 居中对齐有哪些实现方式

  ```
  水平居中：
  inline元素（text-align：center）
  block元素（margin：auto）
  absolute元素：left:50% + margin-left： 负值（为宽度的一半）
  
  垂直居中：
  inline元素：line-height的值等于height的值
  absolute元素：top:50% + margin-top： 负值（为宽度的一半）  （需要知道子元素的宽高）
  absolute元素：top:50% left:50% transform（-50%，-50%）(兼容性)
  absolute元素：left，right，top，right = 0 ； margin：auto  （不需要知道宽高）
  ```

  

### 图文样式

* line-height的继承问题

  ![1590207683677](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590207683677.png)

  ```
  父元素line-height具体数值（如：30px），子元素直接继承line-height:30px；
  父元素line-height比例数值（如：1.5、2），会直接继承该比例，子元素的font-size*父元素比例值；
  父元素line-height百分比数值（如：200%）,子元素继承的行高是 200%*父元素的font-size;（考点
  ```

### 响应式

* rem是什么,em,px

  ```
  rem是个长度单位
  px:绝对长度单位，最常用，
  em:相对长度单位，相对于父元素，不常用，
  rem:相对长度单位，相对于根元素，常用于响应式布局； 
  
  响应式布局常见布局方案：
  1.设置头部meta标签 <meta name="viewport" content="width=device-width, initial-scale=1.0">
  2.通过media-query(媒体查询)，根据不同的屏幕宽度设置根元素的font-size
  rem,基于根元素的相对单位
  @media screen and (max-width: 374px) {
  /* iphone5 或者更小的尺寸，以iphone5的宽度（320px）比例设置font-size */
  html {
  font-size: 86px;
  }
  }
  @media screen and (min-width: 375px) and (max-width: 413px) {
  /* iphone6/7/8 和 iphone x */
  html {
  font-size: 100px;
  }
  }
  @media screen and (min-width: 414px) {
  /* iphone6 或者更大的尺寸，以iphone6p的宽度（414px）比例设置font-size */
  html {
  font-size: 110px;
  }
  }
  body {
  font-size:0.16rem;
  }
  ```

* 如何实现响应式

### CSS3

* 关于CSS３动画

### 清楚浮动的方法（4种）

**1. 额外标签法**：给谁清除浮动，就在其后额外添加一个空白标签 。
优点：通俗易懂，书写方便。（不推荐使用）
缺点：添加许多无意义的标签，结构化比较差。

给元素small清除浮动（在small后添加一个空白标签clear(类名可以随意），设置clear:both;即可）

![img](https://img2018.cnblogs.com/blog/1680537/201907/1680537-20190703112802274-1885563518.png)

![img](https://img2018.cnblogs.com/blog/1680537/201907/1680537-20190703113208658-657572243.png)

**2. 父级添加overflow方法**：可以通过触发BFC的方式，实现清楚浮动效果。
优点：代码简洁（慎重使用，若该父盒子里还有position定位会引起麻烦）
缺点：内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。

![img](https://img2018.cnblogs.com/blog/1680537/201907/1680537-20190703113817758-304851854.png)

注意：别加错位置，是给父亲加（并不是所有的浮动都需要清除，谁影响布局，才清除谁。）

**3. 使用after伪元素清除浮动**：：after方式为空元素的升级版，好处是不用单独加标签了。（较常用）
优点：符合闭合浮动思想，结构语义化正确
缺点：由于IE6-7不支持：after，使用zoom：1，触发hasLayout。

![img](https://img2018.cnblogs.com/blog/1680537/201907/1680537-20190703114149745-648850256.png)

注意：这个也是给父亲添加 clearfix

**4. 使用before和after双伪元素清除浮动**：（较常用）

![img](https://img2018.cnblogs.com/blog/1680537/201907/1680537-20190703115038313-781890830.png)

注意：是给父亲添加clearfix



## 3.JS

### JS变量

``` 
题目:
1.JS中使用typeof能得到哪些类型
instanceof用来判断对象，代码形式为obj1 instanceof obj2（obj1是否是obj2的实例），obj2必须为对象，否则会报错！其返回值为布尔值。
2.何时使用=== 何时使用==
if(obj.a == null) 只用这种情况用== 其他全用===
3.JS中有哪些内置函数
Object  Number  Boolean  String   Array   Function  Date  RegExp  Error
4.JS变量按照存储方式区分为哪些类型,并描述其特点
值类型和引用类型
5.如何理解JSON
JSON只不过是一个JS对象而已,有两个api,也是一个数据存储格式
JSON.stringify({a:10,b:20}) 把对象变为字符串
JSON.parse('{"a":10,"b":20}') 把字符串变为对象
```

* 变量类型

  * 值类型vs引用类型

  * typeof运算符详解

    ```
    typeof undefined //undefined
    typeof 'a' //string
    typeof 12 //number
    typeof true //boolean
    typeof {} //object
    typeof [] //object
    typeof null //object
    typeof alert //function
    typeof NaN //number
    ```

* 变量计算

  * 强制类型转换

    ```
    1.字符串拼接
    var a = 100+ 10
    var b = 100 +'10' //10010
    2.== 运算符  ==之比较“转化成同一类型后的值”看“值”是否相等 (慎用)
    100 == '100' //true
    0 == '' true
    null == undefind //true
    3.逻辑运算
    console.log(10&&0) //0
    console.log('' || 'abc') //abc
    console.log(!window.abc) //true
    判断一个变量会被当做true还是false
    var a = 100
    console.log(!!a)
    if里false情况，0，'', NaN,null,false,undefined
    ```

    

* 理解JSON

### JS原型

```
题目:
1.如何准确判断一个变量是数组类型
arr instanceof Array
2.写一个原型链继承的例子

3.描述new一个对象的过程
创建一个新对象，this指向这个新对象，执行代码，即对this赋值，返回this
4.zepto源码中如何使用原型链
```

* 构造函数

  ```
  通过 （new + 函数名 ）来实例化对象的函数叫构造函数。任何的函数都可以作为构造函数存在。之所以有构造函数与普通函数之分，主要从功能上进行区别的，构造函数的主要功能为 （初始化对象），特点是和new 一起使用。new就是在创建对象，从无到有，构造函数就是在为初始化的对象添加属性和方法。构造函数定义时首字母大写（规范）。
  
  对new理解：new 申请内存, 创建对象,当调用new时，后台会隐式执行new Object()创建对象。所以，通过new创建的字符串、数字是引用类型，而是非值类型。
  ```

  ![1590244156371](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590244156371.png)

  ![1590244600866](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590244600866.png)

* 原型

  5条原型规则！
  1.所有的引用类型（数组、对象、函数），都具有对象特性，即可自由扩展属性（除了“null”之外）；
  2.所有的引用类型（数组、对象、函数），都有一个`__proto__`（隐式原型）属性，属性值是一个普通的对象；
  3.所有的**函数**，都有一个prototype（显式原型）属性，属性值也是一个普通的对象； 原型对象
  4.所有的引用类型（数组、对象、函数），`__proto__`属性值指向（===）它的构造函数的“prototype”属性值。`obj.__proto__ === Object.prototype` 两者都是指向同一个对象，引用类型有隐式原型，函数有显示原型
  5.当试图得到一个对象的某个属性时，如果这个对象本身没有这个属性，那么会去他的_proto_中寻找，即它的构造函数的prototype中寻找 

  ![1590294281093](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590294281093.png)

  ![1590294476117](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590294476117.png)

* 原型链

  ![1590294731709](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590294731709.png)

  ![1590294604635](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590294604635.png)

  

```
instanceof
instanceof 运算符用于检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上。
语法：【对象 instanceof 构造函数】注意，左边必须是对象，否则直接返回false
如：var str = 'xiaoming';
str .__proto__ === String.prototype //true
str instanceof String //false
```

![1590295269324](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590295269324.png)

* 原型链继承

  ![1590295597239](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590295597239.png)

```javascript
function Elem(id){
	this.elem = document.getElementById(id);
}
Elem.prototype.html = function(val){
	var elem = this.elem;
	if(val){
		elem.innerHtml = var;
		return this; //为了链式操作
	}else{
		return elem.innerHtml;
	}
}

Elem.prototype.on = function(type,fn){
	var elem = this.elem;
	elem.addEventListener(type,fn)
	return this
}

var div1 = new Elem('div1');
console.log(div1.html());
div1.html('<p>hello imooc</p>');
div1.on('click',function(){
	alert('hello');
})
div1.html('<p>hello imooc</p>').on('click',function(){
	alert('hello');
})

```

**疑问：**将属性写在原型里与将属性写在构造函数里有什么不同？

1、把方法写在原型中比写在构造函数中消耗的内存更小，因为在内存中一个类的原型只有一个，写在原型中的行为可以被所有实例共享，实例化的时候并不会在实例的内存中再复制一份。

而写在类中的方法，实例化的时候会在每个实例中再复制一份，所以消耗的内存更高
所以没有特殊原因，我们一般把属性写到类中，而行为写到原型中
2、构造函数中定义的属性和方法要  比原型中定义的属性和方法的优先级高，如果定义了同名称的属性和方法，构造函数中的将会覆盖原型中的*

### JS作用域

```
题目：
1.说一下对变量提升的理解
变量提升的作用范围（一段<script>标签，或者一个函数内，
遇到 script 标签的话 js 就进行预解析，将变量 var 和 function 声明提升，但不会执行 function，使用var a = function（）{}的形式创建的函数不会被提升）
JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。
（注意是变量的声明，而不是变量的赋值，如var x ; 会被变量提升，var x = 1 ； 不会被提升，其实本质是var x 被提升了（再其本质是var x = undefined），x = 1 没被提升）
JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。
变量提升：函数声明和变量声明总是会被解释器悄悄地被"提升"到方法体的最顶部。
2.说明this几种不同的使用场景
3.创建10个<a>标签，点击的时候弹出来对应的序号
4.如何理解作用域
5.实际开发中闭包的应用
```

* 上下文环境

  执行上下文：

  ![1590302229526](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590302229526.png)![1590302377916](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590302377916.png)

  this:

  ```
  this要在执行时才能确认值，定义时无法确认
  call改变this的指向
  1.作为构造函数执行
  2.作为对象属性执行
  3.作为普通函数执行
  4.call apply bind  1、apply（{}，""""），一个一个值传进去的;2.call({},[])数组形式传进去的3.bind是加在后面的
  在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。
  1 . 在方法中，this 表示该方法所属的对象。
  如：
  var person = {
  firstName: "John",
  lastName : "Doe",
  id : 5566,
  fullName : function() {
  return this.firstName + " " + this.lastName;
  }
  };
  在“对象”“方法”中， this 指向调用它所在方法的对象。
  在上面一个实例中，this 表示 person 对象。
  fullName 方法所属的对象就是 person。
  2 . 如果单独使用，this 表示全局对象。
  单独使用 this，则它指向全局(Global)对象。
  在浏览器中，window 就是该全局对象为 [object Window]:
  3 . 在函数中，this 表示全局对象。
  全局对象为 [object Window]:
  4 . 在函数中，在严格模式下，this 是未定义的(undefined)。
  "use strict";（严格模式）
  5 . 在事件中，this 表示接收事件的元素。
  6 . 类似 call() 和 apply() 方法可以将 this 引用到任何对象。
  apply 和 call 允许切换函数执行的上下文环境（context），即 this 绑定的对象，可以将 this 引用到任何对象。
  ```

  ![1590307138322](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590307138322.png)

* 作用域

  没有块级作用域

  ```
  JS没有块级作用域（高级编程语言 { } 内定义的变量在外部没法访问，如java语言if（true）{ int num = 3 } 在外部无法访问 num
  ）
  只有局部作用域（函数作用域）（变量在函数内声明，变量为局部作用域）和全局作用域
  
  let 的声明方式与 var 相同，用 let 来代替 var 来声明变量，就可以把变量限制在当前代码块中。
  使用 const 声明的是常量，其值一旦被设定便不可被更改。
  
  1.自由变量一直不断去父级找，呈链式。--》作用域链
  ```

* 闭包

  ```
  闭包的使用场景
  1 . “函数”作为“返回值”，直接return整个函数，或返回函数名（千万不要加括号）
  2 . 函数作为参数传递
  
  例子：计数器
  // 初始化计数器
  var counter = 0;
  // 递增计数器的函数
  function add() {
  counter += 1;
  console.log(counter);
  }
  // 调用三次 add()
  add();
  add();
  add();//输出3，但这种情况下，我们即使不调用add()方法，直接修改counter 的值也可以达到改变计数的值，所以我们需要闭包
  
  var add = (function () {
  var counter = 0;
  return function () {return counter += 1;}
  })();
  add();
  add();
  add();
  // 计数器目前是 3
  
  这段代码可以分解成：
  function outAdd(){
  var counter = 0;
  function innerAdd (){
  return counter += 1;
  }
  return innerAdd;
  }
  var add = outAdd();
  
  
  自由变量，向父作用域去寻找---函数**定义**时的父作用域
  闭包实际应用中主要用于封装变量，收敛权限
  ```

### JS异步

```
1.同步和异步的区别是什么？分别举一个同步和异步的例子
2.一个关于setTimeout的笔试题
3.前端使用异步的场景有哪些
```

* 异步

  ```
  异步：就是不让程序阻塞
  同步任务：主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务
  异步任务：异步任务是指不进入主线程，而进入任务队列的任务，当主线程的任务结束后，任务队列会通知主线程执行任务队列里的任务（任务队列是个先进先出的堆栈）
  一、什么时候需要异步：
  1）在可能发生等待的情况
  2）等待过程中不能像alert一样阻塞程序的时候
  3）因此，所有的“等待的情况”都需要异步
  一句话总结就是需要等待但是又不能阻塞程序的时候需要使用异步
  —————————————————————————————————————————————————
  二、前端使用异步的场景（下面这些场景都需要等待，但是在等待的过程中又不能阻塞程序，所以需要异步，异步的设计主要是因为javascript是一个单线程的语言，单线程只允许同时做一件事情，如果同时需要做多个，那其他的需要去旁边排队去）：
  1）定时任务：setTimeout,setInverval
  2）网络请求：ajax请求，img图片的动态加载
  3）事件绑定或者叫DOM事件，比如一个点击事件，我不知道它什么时候点，但是在它点击之前，我该干什么还是干什么。用addEventListener注册一个类型的事件的时候，浏览器会有一个单独的模块去接收这个东西，当事件被触发的时候，浏览器的某个模块，会把相应的函数扔到异步队列中，如果现在执行栈中是空的，就会直接执行这个函数。
  4）ES6中的Promise
  ————————————————
  ```

  ![1590329512895](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590329512895.png)

* 单线程

  ![1590381054313](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590381054313.png)

### 常用API

```
获取2017-06-10格式的日期
获取随机数，要求是长度一致的字符串格式
写一个能遍历对象和数组的通用forEach函数
```

![1590383973736](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590383973736.png)

![1590384146089](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590384146089.png)

![1590384169169](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590384169169.png)

* 日期和Math

  ```
  Date.now()//获取当前时间的毫秒数，从1970年开始
  var dt = new Date()
  dt.getTime() //获取毫秒数， 从1970年开始
  dt.getFullYear() //年
  dt.getMonth() //月(0-11)
  dt.getDate() //日 （1-31）
  dt.getDay() //星期（0-6）
  dt.getHours() //小时（0-23）
  dt.getMinutes() //分钟（0-59）
  dt.getSeconds() //秒（0-59）
  
  Math对象
  ceil()　　　　向上取整。
  floor()　　　 向下取整。
  round()　　　四舍五入。
  random()　　取随机数。返回（0-1）之间的任意小数，小数点后面的位数不确定，random在前端的应用就是随时改变，清除缓存
  ```

* 数组

  ```
  join()； （原数组 不 改变）
  把数组转换成字符串。元素通过指定的分隔符进行分隔（join()括号里只传一个参数，那就是分隔符，默认不传是，（逗号）分割）
  var arr1 = [1,2,3,4];
  var arrCopy = arr1.join("-");
  console.log(arrCopy); 输出 1-2-3-4
  
  pop() （原数组改变）
  : 删除并返回数组的最后一个元素，只删除一个，而且是最后一个
  var arr1 = [1,2,3,4];
  var arrCopy = arr1.pop();
  console.log(arr1); // 会修改原数组输出[1,2,3]
  console.log(arrCopy); pop函数执行完后返回被删除的元素，返回 4
  
  shift() （原数组改变）
  删除并返回数组的第一个元素
  
  push() （原数组改变）
  接收任意数量的参数，并把它们逐个添加到数组末尾，并返回新的长度（注意返回的是修改后数组的长度）
  var arr1 = [1,2,3,4];
  var arrCopy = arr1.push(5,6);
  console.log(arr1); // 返回[1,2,3,4,5,6]
  console.log(arrCopy); // 返回 5
  
  reverse() （原数组改变）
  颠倒数组中元素的顺序，
  
  slice() （原数组 不 改变）
  返回从原数组中，指定，开始下标到结束下标，之间的项组成的新数组；
  如果有两个参数，该方法返回起始和结束位置之间的项，但不包括结束位置的项
  var arr = [1,3,5,7,9,11];
  var arrCopy = arr.slice(1); //返回[3, 5, 7, 9, 11]
  var arrCopy2 = arr.slice(1,4); //返回[3, 5, 7]
  
  splice（index,howmany,item1,...itemX）
  index参数：必须，整数，规定添加或者删除的位置，使用负数，从数组尾部规定位置。
  howmany参数：必须，要删除的数量，如果为0，则不删除项目。
  tem1,...itemX参数：可选，向数组添加的新项目。
  
  sort() （改变原数组）
  对数组的元素进行排序
  var arr1 = [3,4,1,2,12,32,23,156,1569];
  console.log(arr1.sort()); // 返回[1, 12, 156, 1569, 2, 23, 3, 32, 4] 排序有点智障，因为会把数组内的所有内容转换成字符串在进行比较
  
  解决方法sort()，方法允许传入一个比较函数作为参数，
  小到大：
  function compare(value1, value2) {
  if (value1 < value2) {
  return -1;
  } else if (value1 > value2) {
  return 1;
  } else {
  return 0;
  }
  }
  arr2 = [13, 24, 51, 3];
  console.log(arr2.sort(compare)); // [3, 13, 24, 51]
  
  大到小
  function compare(value1, value2) {
  if (value1 < value2) {
  return 1;
  } else if (value1 > value2) {
  return -1;
  } else {
  return 0;
  }
  }
  arr2 = [13, 24, 51, 3];
  console.log(arr2.sort(compare)); // [51, 24, 13, 3]
  
  或者：
  小到大
  console.log(arr.sort(function(a,b){
  return a - b;
  }))
  大到小
  console.log(arr.sort(function(a,b){
  return b - a;
  }))
  
  
  数组API
  forEach()
  对数组进行遍历循环，对数组中的每一项运行给定函数。这个方法没有返回值。参数都是function类型，默认有传参，参数分别为：遍历的数组内容；第对应的数组索引，数组本身。
  var arr = [1, 2, 3, 4, 5];
  arr.forEach(function(x, index, a){
  console.log(x + '|' + index + '|' + (a === arr));
  });
  // 输出为：
  // 1|0|true
  // 2|1|true
  // 3|2|true
  // 4|3|true
  // 5|4|true
  
  every()
  判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。
  var arr = [1, 2, 3, 4, 5];
  var arr2 = arr.every(function(x) {
  return x < 10;
  });
  console.log(arr2); //true
  var arr3 = arr.every(function(x) {
  return x < 3;
  });
  console.log(arr3); // false
  
  some（）
  判断数组中是否存在满足条件的项，只要有一项满足条件，就会返回true。
  
  filter（）
  “过滤”功能，数组中的每一项运行给定函数，返回满足过滤条件组成的数组。
  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  var arr2 = arr.filter(function (x, index) {
  return x % 3 === 0 ;
  });
  返回：[3, 6, 9]
  
  map() （原数组 不 变）
  对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。
  下面代码利用map方法实现数组中每个数求平方
  var arr = [1, 2, 3, 4, 5];
  var arr2 = arr.map(function(item){
  return item*item;
  });
  console.log(arr2); //[1, 4, 9, 16, 25]
  
  for in 是对对象进行循环遍历
  
  ```

  ![1590382014547](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590382014547.png)

* 对象

### DOM

```
题目：
1.DOM是哪种基本的数据结构？
2.DOM操作的常用API有哪些？
3.DOM节点的attr和property有何区别？
    1.property是对象的属性
    2.atribute是文档标签的属性
```

![1590477024690](C:\Users\baiye\AppData\Roaming\Typora\typora-user-images\1590477024690.png)

* DOM本质

* DOM节点操作

* DOM树操作

* Bom

  ```
  protocol       设置或返回当前 URL 的协议。
  hostname    设置或返回当前 URL 的主机名。
  port              设置或返回当前 URL 的端口号。
  host             设置或返回主机名和当前 URL 的端口号。
  pathname    设置或返回当前 URL 的路径部分。
  hash            设置或返回从井号 (#) 开始的 URL（锚）。
  search         设置或返回从问号 (?) 开始的 URL（查询部分）。
  href              设置或返回完整的 URL。
  history
  History 对象
  History 对象包含用户（在浏览器窗口中）访问过的 URL。
  History 对象是 window 对象的一部分，可通过 window.history 属性对其进行访问。
  注释：没有应用于 History 对象的公开标准，不过所有浏览器都支持该对象。
  History 对象属性
  属性描述
  length返回浏览器历史列表中的 URL 数量。
  History 对象方法
  方法描述
  back()加载 history 列表中的前一个 URL。
  forward()加载 history 列表中的下一个 URL。
  go()加载 history 列表中的某个具体页面。
  History 对象描述
  History 对象最初设计来表示窗口的浏览历史。但出于隐私方面的原因，History 对象不再允许脚本访问已经访问过的实际 URL。唯一保持使用的功能只有back()、forward()和go()方法。
  例子
  
  下面一行代码执行的操作与单击后退按钮执行的操作一样：
  history.back()
  下面一行代码执行的操作与单击两次后退按钮执行的操作一样：
  history.go(-2)
  ```
  
  

## 4.VUE面试题

vue跨域

vue promise

vue created能不能获取dom

vue 传值

vuex的几个参数

vue路由

vue跨页面传值

watch深度监听

## 5.其他面试题

